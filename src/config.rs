use std::fs;
use std::fs::File;
use std::io::Write;
use lazy_static::lazy_static;
use log::error;
use std::sync::Mutex;
use nanoid::nanoid;
// Loads config file
use serde_derive::{Deserialize, Serialize};

#[derive(Deserialize,Clone,Serialize)]
pub struct InternalConfig {
    pub discord_bot_id: u64,
    pub discord_bot_token: String,
    pub kafka_uri: String,
    pub kafka_topic: String,
    pub worker_id: Option<String>,
    pub job_expiration_time: Option<u64> //
}

#[derive(Deserialize,Clone,Serialize)]
pub struct Config {
    pub roles: Roles,
    pub config: InternalConfig
}

#[derive(Deserialize,Clone,Serialize)]
pub struct Roles {
    pub worker: bool,
    pub scheduler: bool
}

pub fn init_config() -> Config {
    let filename = "config.toml"; //TODO: Change to environment variable

    let contents = match fs::read_to_string(filename) {
        Ok(c) => c,
        Err(error) => {
            error!("{}",error);
            panic!("Could not read config file `{}`", filename);
        }
    };

    let mut config: Config = match toml::from_str(&contents) {
        Ok(d) => d,
        Err(error) => {
            error!("{}",error);
            panic!("Unable to load config data from `{}`", filename);
        }
    };
    // Default value

    if config.config.worker_id.is_none() {
        config.config.worker_id = Some(nanoid!());
        let new_config = toml::ser::to_string(&config);
        match new_config {
            Ok(mut new_val_config) => {
                new_val_config = format!("{}{}",new_val_config,"# Worker ID has been autogenerated - DO NOT CHANGE");
                let mut f = File::create("config.toml").unwrap();
                f.write_all(new_val_config.as_bytes()).unwrap();
            },
            Err(e) => error!("Failed to write updated config with worker ID with error: {}",e)

        }
    }

    return config;
}